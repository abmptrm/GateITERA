
C:\Users\kedai\AppData\Local\Temp\arduino\sketches\F9D29BF51A44F78A17D690BDC15F328C/FirmwareGateV2.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	3a c0       	rjmp	.+116    	; 0x76 <__ctors_end>
   2:	5e c0       	rjmp	.+188    	; 0xc0 <__bad_interrupt>
   4:	5d c0       	rjmp	.+186    	; 0xc0 <__bad_interrupt>
   6:	5c c0       	rjmp	.+184    	; 0xc0 <__bad_interrupt>
   8:	5b c0       	rjmp	.+182    	; 0xc0 <__bad_interrupt>
   a:	5a c0       	rjmp	.+180    	; 0xc0 <__bad_interrupt>
   c:	c6 c1       	rjmp	.+908    	; 0x39a <__vector_6>
   e:	36 c2       	rjmp	.+1132   	; 0x47c <__vector_7>
  10:	0e c2       	rjmp	.+1052   	; 0x42e <__vector_8>
  12:	56 c0       	rjmp	.+172    	; 0xc0 <__bad_interrupt>
  14:	55 c0       	rjmp	.+170    	; 0xc0 <__bad_interrupt>
  16:	54 c0       	rjmp	.+168    	; 0xc0 <__bad_interrupt>
  18:	53 c0       	rjmp	.+166    	; 0xc0 <__bad_interrupt>
  1a:	52 c0       	rjmp	.+164    	; 0xc0 <__bad_interrupt>
  1c:	51 c0       	rjmp	.+162    	; 0xc0 <__bad_interrupt>
  1e:	50 c0       	rjmp	.+160    	; 0xc0 <__bad_interrupt>
  20:	4f c0       	rjmp	.+158    	; 0xc0 <__bad_interrupt>
  22:	4e c0       	rjmp	.+156    	; 0xc0 <__bad_interrupt>
  24:	4d c0       	rjmp	.+154    	; 0xc0 <__bad_interrupt>
  26:	4c c0       	rjmp	.+152    	; 0xc0 <__bad_interrupt>
  28:	4b c0       	rjmp	.+150    	; 0xc0 <__bad_interrupt>

0000002a <__trampolines_end>:
__trampolines_start():
  2a:	00 00       	nop
  2c:	00 00       	nop
  2e:	00 00       	nop
  30:	00 02       	muls	r16, r16
  32:	00 00       	nop
  34:	00 01       	movw	r0, r0
  36:	03 04       	cpc	r0, r3
  38:	00 00       	nop
	...

0000003c <port_to_output_PGM>:
  3c:	00 00 3b 00 38 00 00 00 32 00                       ..;.8...2.

00000046 <port_to_mode_PGM>:
  46:	00 00 3a 00 37 00 00 00 31 00                       ..:.7...1.

00000050 <digital_pin_to_port_PGM>:
  50:	04 04 01 01 04 04 04 04 04 02 02 02 02 02 02 02     ................
  60:	02 01                                               ..

00000062 <digital_pin_to_bit_mask_PGM>:
  62:	01 02 02 01 04 08 10 20 40 01 02 04 08 10 20 40     ....... @..... @
  72:	80 04                                               ..

00000074 <__ctors_start>:
__ctors_start():
  74:	27 03       	mulsu	r18, r23

00000076 <__ctors_end>:
__dtors_end():
  76:	11 24       	eor	r1, r1
  78:	1f be       	out	0x3f, r1	; 63
  7a:	cf e5       	ldi	r28, 0x5F	; 95
  7c:	d1 e0       	ldi	r29, 0x01	; 1
  7e:	de bf       	out	0x3e, r29	; 62
  80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  82:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  84:	a4 ea       	ldi	r26, 0xA4	; 164
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  86:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  88:	01 c0       	rjmp	.+2      	; 0x8c <.do_clear_bss_start>

0000008a <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  8a:	1d 92       	st	X+, r1

0000008c <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  8c:	ad 3f       	cpi	r26, 0xFD	; 253
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  8e:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  90:	e1 f7       	brne	.-8      	; 0x8a <.do_clear_bss_loop>

00000092 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  92:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  94:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  96:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  98:	ee ed       	ldi	r30, 0xDE	; 222
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  9a:	f6 e0       	ldi	r31, 0x06	; 6
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  9c:	02 c0       	rjmp	.+4      	; 0xa2 <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  9e:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  a0:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  a2:	a4 3a       	cpi	r26, 0xA4	; 164
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  a4:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  a6:	d9 f7       	brne	.-10     	; 0x9e <__do_copy_data+0xc>

000000a8 <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  a8:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  aa:	cb e3       	ldi	r28, 0x3B	; 59
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  ac:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  ae:	03 c0       	rjmp	.+6      	; 0xb6 <__do_global_ctors+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  b0:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  b2:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  b4:	03 d3       	rcall	.+1542   	; 0x6bc <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  b6:	ca 33       	cpi	r28, 0x3A	; 58
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  b8:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  ba:	d1 f7       	brne	.-12     	; 0xb0 <__do_global_ctors+0x8>
  bc:	0c d2       	rcall	.+1048   	; 0x4d6 <main>
  be:	0d c3       	rjmp	.+1562   	; 0x6da <_exit>

000000c0 <__bad_interrupt>:
__vector_1():
  c0:	9f cf       	rjmp	.-194    	; 0x0 <__vectors>

000000c2 <micros>:
micros():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:360
    unsigned int r; // needed for some frequencies, optimized away otherwise
    unsigned char f; // temporary storage for millis fraction counter
    unsigned char q = 0; // record whether an overflow is flagged
#endif
    unsigned long m;
    uint8_t t, oldSREG = SREG;
  c2:	3f b7       	in	r19, 0x3f	; 63
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:362

    cli();
  c4:	f8 94       	cli
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:367
#ifdef CORRECT_EXACT_MICROS
    m = millis_timer_millis;
    f = millis_timer_fract;
#else
    m = millis_timer_overflow_count;
  c6:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <millis_timer_overflow_count>
  ca:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <millis_timer_overflow_count+0x1>
  ce:	a0 91 dc 00 	lds	r26, 0x00DC	; 0x8000dc <millis_timer_overflow_count+0x2>
  d2:	b0 91 dd 00 	lds	r27, 0x00DD	; 0x8000dd <millis_timer_overflow_count+0x3>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:370
#endif
  #if defined(TCNT0) && (TIMER_TO_USE_FOR_MILLIS == 0) && !defined(TCW0)
    t = TCNT0;
  d6:	22 b7       	in	r18, 0x32	; 50
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:389
      m++;
    #else
      q = 1;
    #endif
  #elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 0)
    if ((TIFR & _BV(TOV0)) && (t < 255))
  d8:	08 b6       	in	r0, 0x38	; 56
  da:	01 fe       	sbrs	r0, 1
  dc:	05 c0       	rjmp	.+10     	; 0xe8 <micros+0x26>
  de:	2f 3f       	cpi	r18, 0xFF	; 255
  e0:	19 f0       	breq	.+6      	; 0xe8 <micros+0x26>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:391
    #ifndef CORRECT_EXACT_MICROS
      m++;
  e2:	01 96       	adiw	r24, 0x01	; 1
  e4:	a1 1d       	adc	r26, r1
  e6:	b1 1d       	adc	r27, r1
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:411
    #else
      q = 1;
    #endif
  #endif

    SREG = oldSREG;
  e8:	3f bf       	out	0x3f, r19	; 63
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:453
  #else
  #if F_CPU < 1000000L
    return ((m << 8) + t) * MillisTimer_Prescale_Value * (1000000L/F_CPU);
  #else
    #if (MillisTimer_Prescale_Value % clockCyclesPerMicrosecond() == 0 && (F_CPU % 1000000 == 0 )) // Can we just do it the naive way? If so great!
      return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
  ea:	ba 2f       	mov	r27, r26
  ec:	a9 2f       	mov	r26, r25
  ee:	98 2f       	mov	r25, r24
  f0:	88 27       	eor	r24, r24
  f2:	bc 01       	movw	r22, r24
  f4:	cd 01       	movw	r24, r26
  f6:	62 0f       	add	r22, r18
  f8:	71 1d       	adc	r23, r1
  fa:	81 1d       	adc	r24, r1
  fc:	91 1d       	adc	r25, r1
  fe:	43 e0       	ldi	r20, 0x03	; 3
 100:	66 0f       	add	r22, r22
 102:	77 1f       	adc	r23, r23
 104:	88 1f       	adc	r24, r24
 106:	99 1f       	adc	r25, r25
 108:	4a 95       	dec	r20
 10a:	d1 f7       	brne	.-12     	; 0x100 <micros+0x3e>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:508
      //return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + ((t+(((m<<8)%clockCyclesPerMicrosecond())) * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond()));
      return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + (t * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
    #endif
  #endif
  #endif // !CORRECT_EXACT_MICROS
  }
 10c:	08 95       	ret

0000010e <delay.constprop.2>:
delay.constprop.2():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:515
  static void __empty() {
    // Empty
  }
  void yield(void) __attribute__ ((weak, alias("__empty")));

  void delay(unsigned long ms)
 10e:	cf 92       	push	r12
 110:	df 92       	push	r13
 112:	ef 92       	push	r14
 114:	ff 92       	push	r15
 116:	cf 93       	push	r28
 118:	df 93       	push	r29
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:518
  {
    #if (F_CPU>=1000000L)
    uint16_t start = (uint16_t)micros();
 11a:	d3 df       	rcall	.-90     	; 0xc2 <micros>
 11c:	eb 01       	movw	r28, r22
 11e:	84 ef       	ldi	r24, 0xF4	; 244
 120:	c8 2e       	mov	r12, r24
 122:	dd 24       	eor	r13, r13
 124:	d3 94       	inc	r13
 126:	e1 2c       	mov	r14, r1
 128:	f1 2c       	mov	r15, r1
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:522

    while (ms > 0) {
      yield();
      while (((uint16_t)micros() - start) >= 1000 && ms) {
 12a:	cb df       	rcall	.-106    	; 0xc2 <micros>
 12c:	6c 1b       	sub	r22, r28
 12e:	7d 0b       	sbc	r23, r29
 130:	68 3e       	cpi	r22, 0xE8	; 232
 132:	73 40       	sbci	r23, 0x03	; 3
 134:	a0 f0       	brcs	.+40     	; 0x15e <delay.constprop.2+0x50>
 136:	c1 14       	cp	r12, r1
 138:	d1 04       	cpc	r13, r1
 13a:	e1 04       	cpc	r14, r1
 13c:	f1 04       	cpc	r15, r1
 13e:	39 f4       	brne	.+14     	; 0x14e <delay.constprop.2+0x40>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:532
    #else
    uint32_t start = millis();
    while((millis() - start) < ms)  /* NOP */yield();
    return;
    #endif
  }
 140:	df 91       	pop	r29
 142:	cf 91       	pop	r28
 144:	ff 90       	pop	r15
 146:	ef 90       	pop	r14
 148:	df 90       	pop	r13
 14a:	cf 90       	pop	r12
 14c:	08 95       	ret
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:523
    uint16_t start = (uint16_t)micros();

    while (ms > 0) {
      yield();
      while (((uint16_t)micros() - start) >= 1000 && ms) {
        ms--;
 14e:	81 e0       	ldi	r24, 0x01	; 1
 150:	c8 1a       	sub	r12, r24
 152:	d1 08       	sbc	r13, r1
 154:	e1 08       	sbc	r14, r1
 156:	f1 08       	sbc	r15, r1
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:524
        start += 1000;
 158:	c8 51       	subi	r28, 0x18	; 24
 15a:	dc 4f       	sbci	r29, 0xFC	; 252
 15c:	e6 cf       	rjmp	.-52     	; 0x12a <delay.constprop.2+0x1c>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:520
  void delay(unsigned long ms)
  {
    #if (F_CPU>=1000000L)
    uint16_t start = (uint16_t)micros();

    while (ms > 0) {
 15e:	c1 14       	cp	r12, r1
 160:	d1 04       	cpc	r13, r1
 162:	e1 04       	cpc	r14, r1
 164:	f1 04       	cpc	r15, r1
 166:	09 f7       	brne	.-62     	; 0x12a <delay.constprop.2+0x1c>
 168:	eb cf       	rjmp	.-42     	; 0x140 <delay.constprop.2+0x32>

0000016a <Print::write(unsigned char const*, unsigned int)>:
_ZN5Print5writeEPKhj():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Print.cpp:34

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 16a:	cf 92       	push	r12
 16c:	df 92       	push	r13
 16e:	ef 92       	push	r14
 170:	ff 92       	push	r15
 172:	0f 93       	push	r16
 174:	1f 93       	push	r17
 176:	cf 93       	push	r28
 178:	df 93       	push	r29
 17a:	6c 01       	movw	r12, r24
 17c:	eb 01       	movw	r28, r22
 17e:	7b 01       	movw	r14, r22
 180:	e4 0e       	add	r14, r20
 182:	f5 1e       	adc	r15, r21
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Print.cpp:35
  size_t n = 0;
 184:	10 e0       	ldi	r17, 0x00	; 0
 186:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Print.cpp:36
  while (size--) {
 188:	ce 15       	cp	r28, r14
 18a:	df 05       	cpc	r29, r15
 18c:	61 f0       	breq	.+24     	; 0x1a6 <Print::write(unsigned char const*, unsigned int)+0x3c>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Print.cpp:37
    n += write(*buffer++);
 18e:	69 91       	ld	r22, Y+
 190:	d6 01       	movw	r26, r12
 192:	ed 91       	ld	r30, X+
 194:	fc 91       	ld	r31, X
 196:	01 90       	ld	r0, Z+
 198:	f0 81       	ld	r31, Z
 19a:	e0 2d       	mov	r30, r0
 19c:	c6 01       	movw	r24, r12
 19e:	09 95       	icall
 1a0:	08 0f       	add	r16, r24
 1a2:	19 1f       	adc	r17, r25
 1a4:	f1 cf       	rjmp	.-30     	; 0x188 <Print::write(unsigned char const*, unsigned int)+0x1e>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Print.cpp:40
  }
  return n;
}
 1a6:	c8 01       	movw	r24, r16
 1a8:	df 91       	pop	r29
 1aa:	cf 91       	pop	r28
 1ac:	1f 91       	pop	r17
 1ae:	0f 91       	pop	r16
 1b0:	ff 90       	pop	r15
 1b2:	ef 90       	pop	r14
 1b4:	df 90       	pop	r13
 1b6:	cf 90       	pop	r12
 1b8:	08 95       	ret

000001ba <HardwareSerial::write(unsigned char)>:
_ZN14HardwareSerial5writeEh():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:361
  while (_tx_buffer->head != _tx_buffer->tail)
    ;
}

size_t HardwareSerial::write(uint8_t c)
{
 1ba:	fc 01       	movw	r30, r24
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:362
  byte i = (_tx_buffer->head + 1) % SERIAL_BUFFER_SIZE;
 1bc:	a6 85       	ldd	r26, Z+14	; 0x0e
 1be:	b7 85       	ldd	r27, Z+15	; 0x0f
 1c0:	50 96       	adiw	r26, 0x10	; 16
 1c2:	2c 91       	ld	r18, X
 1c4:	50 97       	sbiw	r26, 0x10	; 16
 1c6:	30 e0       	ldi	r19, 0x00	; 0
 1c8:	2f 5f       	subi	r18, 0xFF	; 255
 1ca:	3f 4f       	sbci	r19, 0xFF	; 255
 1cc:	2f 70       	andi	r18, 0x0F	; 15
 1ce:	33 27       	eor	r19, r19
 1d0:	82 2f       	mov	r24, r18
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:367

  // If the output buffer is full, there's nothing for it other than to
  // wait for the interrupt handler to empty it a bit
  // ???: return 0 here instead?
  while (i == _tx_buffer->tail)
 1d2:	51 96       	adiw	r26, 0x11	; 17
 1d4:	9c 91       	ld	r25, X
 1d6:	51 97       	sbiw	r26, 0x11	; 17
 1d8:	98 17       	cp	r25, r24
 1da:	d9 f3       	breq	.-10     	; 0x1d2 <HardwareSerial::write(unsigned char)+0x18>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:370
    ;

  _tx_buffer->buffer[_tx_buffer->head] = c;
 1dc:	50 96       	adiw	r26, 0x10	; 16
 1de:	8c 91       	ld	r24, X
 1e0:	50 97       	sbiw	r26, 0x10	; 16
 1e2:	a8 0f       	add	r26, r24
 1e4:	b1 1d       	adc	r27, r1
 1e6:	6c 93       	st	X, r22
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:371
  _tx_buffer->head = i;
 1e8:	a6 85       	ldd	r26, Z+14	; 0x0e
 1ea:	b7 85       	ldd	r27, Z+15	; 0x0f
 1ec:	50 96       	adiw	r26, 0x10	; 16
 1ee:	2c 93       	st	X, r18
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:374

  #if ( defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) )
  sbi(*_ucsrb, _udrie);
 1f0:	a6 89       	ldd	r26, Z+22	; 0x16
 1f2:	b7 89       	ldd	r27, Z+23	; 0x17
 1f4:	8c 91       	ld	r24, X
 1f6:	95 8d       	ldd	r25, Z+29	; 0x1d
 1f8:	21 e0       	ldi	r18, 0x01	; 1
 1fa:	30 e0       	ldi	r19, 0x00	; 0
 1fc:	01 c0       	rjmp	.+2      	; 0x200 <HardwareSerial::write(unsigned char)+0x46>
 1fe:	22 0f       	add	r18, r18
 200:	9a 95       	dec	r25
 202:	ea f7       	brpl	.-6      	; 0x1fe <HardwareSerial::write(unsigned char)+0x44>
 204:	82 2b       	or	r24, r18
 206:	8c 93       	st	X, r24
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:387
  }
  #endif


  return 1;
}
 208:	81 e0       	ldi	r24, 0x01	; 1
 20a:	90 e0       	ldi	r25, 0x00	; 0
 20c:	08 95       	ret

0000020e <HardwareSerial::flush()>:
_ZN14HardwareSerial5flushEv():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:356
  }
}

void HardwareSerial::flush()
{
  while (_tx_buffer->head != _tx_buffer->tail)
 20e:	dc 01       	movw	r26, r24
 210:	1e 96       	adiw	r26, 0x0e	; 14
 212:	ed 91       	ld	r30, X+
 214:	fc 91       	ld	r31, X
 216:	90 89       	ldd	r25, Z+16	; 0x10
 218:	81 89       	ldd	r24, Z+17	; 0x11
 21a:	98 13       	cpse	r25, r24
 21c:	fc cf       	rjmp	.-8      	; 0x216 <HardwareSerial::flush()+0x8>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:358
    ;
}
 21e:	08 95       	ret

00000220 <HardwareSerial::read()>:
_ZN14HardwareSerial4readEv():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:345
}

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer->head == _rx_buffer->tail) {
 220:	dc 01       	movw	r26, r24
 222:	1c 96       	adiw	r26, 0x0c	; 12
 224:	ed 91       	ld	r30, X+
 226:	fc 91       	ld	r31, X
 228:	90 89       	ldd	r25, Z+16	; 0x10
 22a:	81 89       	ldd	r24, Z+17	; 0x11
 22c:	98 17       	cp	r25, r24
 22e:	71 f0       	breq	.+28     	; 0x24c <HardwareSerial::read()+0x2c>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:348
    return -1;
  } else {
    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
 230:	a1 89       	ldd	r26, Z+17	; 0x11
 232:	ae 0f       	add	r26, r30
 234:	bf 2f       	mov	r27, r31
 236:	b1 1d       	adc	r27, r1
 238:	8c 91       	ld	r24, X
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:349
    _rx_buffer->tail = (_rx_buffer->tail + 1) % SERIAL_BUFFER_SIZE;
 23a:	21 89       	ldd	r18, Z+17	; 0x11
 23c:	30 e0       	ldi	r19, 0x00	; 0
 23e:	2f 5f       	subi	r18, 0xFF	; 255
 240:	3f 4f       	sbci	r19, 0xFF	; 255
 242:	2f 70       	andi	r18, 0x0F	; 15
 244:	33 27       	eor	r19, r19
 246:	21 8b       	std	Z+17, r18	; 0x11
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:350
    return c;
 248:	90 e0       	ldi	r25, 0x00	; 0
 24a:	08 95       	ret
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:346

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer->head == _rx_buffer->tail) {
    return -1;
 24c:	8f ef       	ldi	r24, 0xFF	; 255
 24e:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:352
  } else {
    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
    _rx_buffer->tail = (_rx_buffer->tail + 1) % SERIAL_BUFFER_SIZE;
    return c;
  }
}
 250:	08 95       	ret

00000252 <HardwareSerial::peek()>:
_ZN14HardwareSerial4peekEv():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:335
  return (unsigned int)(SERIAL_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % SERIAL_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer->head == _rx_buffer->tail) {
 252:	dc 01       	movw	r26, r24
 254:	1c 96       	adiw	r26, 0x0c	; 12
 256:	ed 91       	ld	r30, X+
 258:	fc 91       	ld	r31, X
 25a:	90 89       	ldd	r25, Z+16	; 0x10
 25c:	81 89       	ldd	r24, Z+17	; 0x11
 25e:	98 17       	cp	r25, r24
 260:	31 f0       	breq	.+12     	; 0x26e <HardwareSerial::peek()+0x1c>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:338
    return -1;
  } else {
    return _rx_buffer->buffer[_rx_buffer->tail];
 262:	81 89       	ldd	r24, Z+17	; 0x11
 264:	e8 0f       	add	r30, r24
 266:	f1 1d       	adc	r31, r1
 268:	80 81       	ld	r24, Z
 26a:	90 e0       	ldi	r25, 0x00	; 0
 26c:	08 95       	ret
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:336
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer->head == _rx_buffer->tail) {
    return -1;
 26e:	8f ef       	ldi	r24, 0xFF	; 255
 270:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:340
  } else {
    return _rx_buffer->buffer[_rx_buffer->tail];
  }
}
 272:	08 95       	ret

00000274 <HardwareSerial::available()>:
_ZN14HardwareSerial9availableEv():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:330
  _rx_buffer->head = _rx_buffer->tail;
}

int HardwareSerial::available(void)
{
  return (unsigned int)(SERIAL_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % SERIAL_BUFFER_SIZE;
 274:	dc 01       	movw	r26, r24
 276:	1c 96       	adiw	r26, 0x0c	; 12
 278:	ed 91       	ld	r30, X+
 27a:	fc 91       	ld	r31, X
 27c:	80 89       	ldd	r24, Z+16	; 0x10
 27e:	21 89       	ldd	r18, Z+17	; 0x11
 280:	90 e0       	ldi	r25, 0x00	; 0
 282:	40 96       	adiw	r24, 0x10	; 16
 284:	82 1b       	sub	r24, r18
 286:	91 09       	sbc	r25, r1
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:331
}
 288:	8f 70       	andi	r24, 0x0F	; 15
 28a:	99 27       	eor	r25, r25
 28c:	08 95       	ret

0000028e <pinMode.constprop.8>:
pinMode.constprop.8():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:35
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t bit = digitalPinToBitMask(pin);
 28e:	90 e0       	ldi	r25, 0x00	; 0
 290:	fc 01       	movw	r30, r24
 292:	ee 59       	subi	r30, 0x9E	; 158
 294:	ff 4f       	sbci	r31, 0xFF	; 255
 296:	24 91       	lpm	r18, Z
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:36
  uint8_t port = digitalPinToPort(pin);
 298:	80 5b       	subi	r24, 0xB0	; 176
 29a:	9f 4f       	sbci	r25, 0xFF	; 255
 29c:	fc 01       	movw	r30, r24
 29e:	84 91       	lpm	r24, Z
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:39
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
 2a0:	88 23       	and	r24, r24
 2a2:	99 f0       	breq	.+38     	; 0x2ca <pinMode.constprop.8+0x3c>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:41

  reg = portModeRegister(port);
 2a4:	90 e0       	ldi	r25, 0x00	; 0
 2a6:	88 0f       	add	r24, r24
 2a8:	99 1f       	adc	r25, r25
 2aa:	fc 01       	movw	r30, r24
 2ac:	ea 5b       	subi	r30, 0xBA	; 186
 2ae:	ff 4f       	sbci	r31, 0xFF	; 255
 2b0:	a5 91       	lpm	r26, Z+
 2b2:	b4 91       	lpm	r27, Z
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:42
  out = portOutputRegister(port);
 2b4:	fc 01       	movw	r30, r24
 2b6:	e4 5c       	subi	r30, 0xC4	; 196
 2b8:	ff 4f       	sbci	r31, 0xFF	; 255
 2ba:	85 91       	lpm	r24, Z+
 2bc:	94 91       	lpm	r25, Z
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:57
                cli();
    *reg &= ~bit;
    *out |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 2be:	8f b7       	in	r24, 0x3f	; 63
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:58
                cli();
 2c0:	f8 94       	cli
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:59
    *reg |= bit;
 2c2:	ec 91       	ld	r30, X
 2c4:	e2 2b       	or	r30, r18
 2c6:	ec 93       	st	X, r30
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:60
    SREG = oldSREG;
 2c8:	8f bf       	out	0x3f, r24	; 63
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:62
  }
}
 2ca:	08 95       	ret

000002cc <digitalWrite>:
digitalWrite():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:139
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t timer = digitalPinToTimer(pin);
 2cc:	90 e0       	ldi	r25, 0x00	; 0
 2ce:	fc 01       	movw	r30, r24
 2d0:	e6 5d       	subi	r30, 0xD6	; 214
 2d2:	ff 4f       	sbci	r31, 0xFF	; 255
 2d4:	34 91       	lpm	r19, Z
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:140
  uint8_t bit = digitalPinToBitMask(pin);
 2d6:	fc 01       	movw	r30, r24
 2d8:	ee 59       	subi	r30, 0x9E	; 158
 2da:	ff 4f       	sbci	r31, 0xFF	; 255
 2dc:	24 91       	lpm	r18, Z
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:141
  uint8_t port = digitalPinToPort(pin);
 2de:	fc 01       	movw	r30, r24
 2e0:	e0 5b       	subi	r30, 0xB0	; 176
 2e2:	ff 4f       	sbci	r31, 0xFF	; 255
 2e4:	e4 91       	lpm	r30, Z
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:144
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
 2e6:	ee 23       	and	r30, r30
 2e8:	b9 f0       	breq	.+46     	; 0x318 <digitalWrite+0x4c>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:148

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 2ea:	33 23       	and	r19, r19
 2ec:	29 f0       	breq	.+10     	; 0x2f8 <digitalWrite+0x2c>
turnOffPWM():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:67
}

static void turnOffPWM(uint8_t timer)
{
  #if defined(TCCR0A) && defined(COM0A1)
    if( timer == TIMER0A){
 2ee:	31 30       	cpi	r19, 0x01	; 1
 2f0:	a1 f4       	brne	.+40     	; 0x31a <digitalWrite+0x4e>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:68
      cbi(TCCR0A, COM0A1);
 2f2:	80 b7       	in	r24, 0x30	; 48
 2f4:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:74
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
      cbi(TCCR0A, COM0B1);
 2f6:	80 bf       	out	0x30, r24	; 48
digitalWrite():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:150

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);
 2f8:	f0 e0       	ldi	r31, 0x00	; 0
 2fa:	ee 0f       	add	r30, r30
 2fc:	ff 1f       	adc	r31, r31
 2fe:	e4 5c       	subi	r30, 0xC4	; 196
 300:	ff 4f       	sbci	r31, 0xFF	; 255
 302:	a5 91       	lpm	r26, Z+
 304:	b4 91       	lpm	r27, Z
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:153

  if (val == LOW) {
    uint8_t oldSREG = SREG;
 306:	8f b7       	in	r24, 0x3f	; 63
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:152
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);

  if (val == LOW) {
 308:	61 11       	cpse	r22, r1
 30a:	17 c0       	rjmp	.+46     	; 0x33a <digitalWrite+0x6e>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:154
    uint8_t oldSREG = SREG;
    cli();
 30c:	f8 94       	cli
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:155
    *out &= ~bit;
 30e:	ec 91       	ld	r30, X
 310:	20 95       	com	r18
 312:	2e 23       	and	r18, r30
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:160
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
 314:	2c 93       	st	X, r18
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:161
    SREG = oldSREG;
 316:	8f bf       	out	0x3f, r24	; 63
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:163
  }
}
 318:	08 95       	ret
turnOffPWM():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:73
      cbi(TCCR0A, COM0A1);
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
 31a:	32 30       	cpi	r19, 0x02	; 2
 31c:	19 f4       	brne	.+6      	; 0x324 <digitalWrite+0x58>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:74
      cbi(TCCR0A, COM0B1);
 31e:	80 b7       	in	r24, 0x30	; 48
 320:	8f 7d       	andi	r24, 0xDF	; 223
 322:	e9 cf       	rjmp	.-46     	; 0x2f6 <digitalWrite+0x2a>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:118
        GTCCR &= ~(1<<COM1B1);
        //cbi(GTCCR, COM1B1);
      } else
    #endif
    #if defined(TCCR1A) && defined(COM1A1) // civilized parts
      if( timer == TIMER1A){
 324:	33 30       	cpi	r19, 0x03	; 3
 326:	21 f4       	brne	.+8      	; 0x330 <digitalWrite+0x64>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:119
        TCCR1A &= ~(1<<COM1A1);
 328:	8f b5       	in	r24, 0x2f	; 47
 32a:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:126
      } else
    #endif

    #if defined(TCCR1A) && defined(COM1B1) // civilized parts
      if( timer == TIMER1B){
        TCCR1A &= ~(1<<COM1B1);
 32c:	8f bd       	out	0x2f, r24	; 47
 32e:	e4 cf       	rjmp	.-56     	; 0x2f8 <digitalWrite+0x2c>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:125
        //cbi(TCCR1A, COM1A0);
      } else
    #endif

    #if defined(TCCR1A) && defined(COM1B1) // civilized parts
      if( timer == TIMER1B){
 330:	34 30       	cpi	r19, 0x04	; 4
 332:	11 f7       	brne	.-60     	; 0x2f8 <digitalWrite+0x2c>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:126
        TCCR1A &= ~(1<<COM1B1);
 334:	8f b5       	in	r24, 0x2f	; 47
 336:	8f 7d       	andi	r24, 0xDF	; 223
 338:	f9 cf       	rjmp	.-14     	; 0x32c <digitalWrite+0x60>
digitalWrite():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:159
    cli();
    *out &= ~bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
 33a:	f8 94       	cli
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:160
    *out |= bit;
 33c:	ec 91       	ld	r30, X
 33e:	2e 2b       	or	r18, r30
 340:	e9 cf       	rjmp	.-46     	; 0x314 <digitalWrite+0x48>

00000342 <standby()>:
_Z7standbyv():
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:87
  digitalWrite (Hijau, LOW);
}

void standby () {

  digitalWrite (Hitam, LOW);
 342:	60 e0       	ldi	r22, 0x00	; 0
 344:	89 e0       	ldi	r24, 0x09	; 9
 346:	c2 df       	rcall	.-124    	; 0x2cc <digitalWrite>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:88
  digitalWrite (Kuning, LOW);
 348:	60 e0       	ldi	r22, 0x00	; 0
 34a:	8a e0       	ldi	r24, 0x0A	; 10
 34c:	bf df       	rcall	.-130    	; 0x2cc <digitalWrite>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:89
  digitalWrite (Hijau, LOW);
 34e:	60 e0       	ldi	r22, 0x00	; 0
 350:	8b e0       	ldi	r24, 0x0B	; 11
 352:	bc cf       	rjmp	.-136    	; 0x2cc <digitalWrite>

00000354 <Print::println(char const*) [clone .constprop.3]>:
_ZN5Print7printlnEPKc.constprop.3():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Print.cpp:133
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
 354:	0f 93       	push	r16
 356:	1f 93       	push	r17
 358:	cf 93       	push	r28
 35a:	df 93       	push	r29
write():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Print.h:81

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) { return write((const uint8_t *)str, strlen(str)); }
 35c:	fc 01       	movw	r30, r24
 35e:	01 90       	ld	r0, Z+
 360:	00 20       	and	r0, r0
 362:	e9 f7       	brne	.-6      	; 0x35e <Print::println(char const*) [clone .constprop.3]+0xa>
 364:	31 97       	sbiw	r30, 0x01	; 1
 366:	af 01       	movw	r20, r30
 368:	48 1b       	sub	r20, r24
 36a:	59 0b       	sbc	r21, r25
 36c:	bc 01       	movw	r22, r24
 36e:	8e ed       	ldi	r24, 0xDE	; 222
 370:	90 e0       	ldi	r25, 0x00	; 0
 372:	fb de       	rcall	.-522    	; 0x16a <Print::write(unsigned char const*, unsigned int)>
 374:	ec 01       	movw	r28, r24
print():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Print.cpp:58
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 376:	6d e0       	ldi	r22, 0x0D	; 13
 378:	8e ed       	ldi	r24, 0xDE	; 222
 37a:	90 e0       	ldi	r25, 0x00	; 0
 37c:	1e df       	rcall	.-452    	; 0x1ba <HardwareSerial::write(unsigned char)>
 37e:	8c 01       	movw	r16, r24
 380:	6a e0       	ldi	r22, 0x0A	; 10
 382:	8e ed       	ldi	r24, 0xDE	; 222
 384:	90 e0       	ldi	r25, 0x00	; 0
 386:	19 df       	rcall	.-462    	; 0x1ba <HardwareSerial::write(unsigned char)>
_ZN5Print7printlnEPKc.constprop.3():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Print.cpp:136
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 388:	c0 0f       	add	r28, r16
 38a:	d1 1f       	adc	r29, r17
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Print.cpp:138
  return n;
}
 38c:	8c 0f       	add	r24, r28
 38e:	9d 1f       	adc	r25, r29
 390:	df 91       	pop	r29
 392:	cf 91       	pop	r28
 394:	1f 91       	pop	r17
 396:	0f 91       	pop	r16
 398:	08 95       	ret

0000039a <__vector_6>:
__vector_6():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:308
      #error "cannot find Millis() timer overflow vector"
    #endif
  #else
    #error "Millis() timer not defined!"
  #endif
  {
 39a:	1f 92       	push	r1
 39c:	0f 92       	push	r0
 39e:	0f b6       	in	r0, 0x3f	; 63
 3a0:	0f 92       	push	r0
 3a2:	11 24       	eor	r1, r1
 3a4:	2f 93       	push	r18
 3a6:	3f 93       	push	r19
 3a8:	8f 93       	push	r24
 3aa:	9f 93       	push	r25
 3ac:	af 93       	push	r26
 3ae:	bf 93       	push	r27
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:311
    // copy these to local variables so they can be stored in registers
    // (volatile variables must be read from memory on every access)
    unsigned long m = millis_timer_millis;
 3b0:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <millis_timer_millis>
 3b4:	90 91 d7 00 	lds	r25, 0x00D7	; 0x8000d7 <millis_timer_millis+0x1>
 3b8:	a0 91 d8 00 	lds	r26, 0x00D8	; 0x8000d8 <millis_timer_millis+0x2>
 3bc:	b0 91 d9 00 	lds	r27, 0x00D9	; 0x8000d9 <millis_timer_millis+0x3>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:312
    unsigned char f = millis_timer_fract;
 3c0:	30 91 d5 00 	lds	r19, 0x00D5	; 0x8000d5 <millis_timer_fract>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:319
    static unsigned char correct_exact = 0;     // rollover intended
    if (++correct_exact < CORRECT_EXACT_MANY) {
      ++f;
    }
#endif
    f += FRACT_INC;
 3c4:	26 e0       	ldi	r18, 0x06	; 6
 3c6:	23 0f       	add	r18, r19
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:321

    if (f >= FRACT_MAX)
 3c8:	2d 37       	cpi	r18, 0x7D	; 125
 3ca:	68 f1       	brcs	.+90     	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:323
    {
      f -= FRACT_MAX;
 3cc:	29 e8       	ldi	r18, 0x89	; 137
 3ce:	23 0f       	add	r18, r19
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:324
      m += MILLIS_INC + 1;
 3d0:	03 96       	adiw	r24, 0x03	; 3
 3d2:	a1 1d       	adc	r26, r1
 3d4:	b1 1d       	adc	r27, r1
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:331
    else
    {
      m += MILLIS_INC;
    }

    millis_timer_fract = f;
 3d6:	20 93 d5 00 	sts	0x00D5, r18	; 0x8000d5 <millis_timer_fract>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:332
    millis_timer_millis = m;
 3da:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <millis_timer_millis>
 3de:	90 93 d7 00 	sts	0x00D7, r25	; 0x8000d7 <millis_timer_millis+0x1>
 3e2:	a0 93 d8 00 	sts	0x00D8, r26	; 0x8000d8 <millis_timer_millis+0x2>
 3e6:	b0 93 d9 00 	sts	0x00D9, r27	; 0x8000d9 <millis_timer_millis+0x3>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:334
#ifndef CORRECT_EXACT_MICROS
    millis_timer_overflow_count++;
 3ea:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <millis_timer_overflow_count>
 3ee:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <millis_timer_overflow_count+0x1>
 3f2:	a0 91 dc 00 	lds	r26, 0x00DC	; 0x8000dc <millis_timer_overflow_count+0x2>
 3f6:	b0 91 dd 00 	lds	r27, 0x00DD	; 0x8000dd <millis_timer_overflow_count+0x3>
 3fa:	01 96       	adiw	r24, 0x01	; 1
 3fc:	a1 1d       	adc	r26, r1
 3fe:	b1 1d       	adc	r27, r1
 400:	80 93 da 00 	sts	0x00DA, r24	; 0x8000da <millis_timer_overflow_count>
 404:	90 93 db 00 	sts	0x00DB, r25	; 0x8000db <millis_timer_overflow_count+0x1>
 408:	a0 93 dc 00 	sts	0x00DC, r26	; 0x8000dc <millis_timer_overflow_count+0x2>
 40c:	b0 93 dd 00 	sts	0x00DD, r27	; 0x8000dd <millis_timer_overflow_count+0x3>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:336
#endif
  }
 410:	bf 91       	pop	r27
 412:	af 91       	pop	r26
 414:	9f 91       	pop	r25
 416:	8f 91       	pop	r24
 418:	3f 91       	pop	r19
 41a:	2f 91       	pop	r18
 41c:	0f 90       	pop	r0
 41e:	0f be       	out	0x3f, r0	; 63
 420:	0f 90       	pop	r0
 422:	1f 90       	pop	r1
 424:	18 95       	reti
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:328
      f -= FRACT_MAX;
      m += MILLIS_INC + 1;
    }
    else
    {
      m += MILLIS_INC;
 426:	02 96       	adiw	r24, 0x02	; 2
 428:	a1 1d       	adc	r26, r1
 42a:	b1 1d       	adc	r27, r1
 42c:	d4 cf       	rjmp	.-88     	; 0x3d6 <__vector_6+0x3c>

0000042e <__vector_8>:
__vector_8():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:182
ISR(USART0_UDRE_vect)
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#endif
#if !defined(LIN_TC_vect)
{
 42e:	1f 92       	push	r1
 430:	0f 92       	push	r0
 432:	0f b6       	in	r0, 0x3f	; 63
 434:	0f 92       	push	r0
 436:	11 24       	eor	r1, r1
 438:	2f 93       	push	r18
 43a:	8f 93       	push	r24
 43c:	9f 93       	push	r25
 43e:	ef 93       	push	r30
 440:	ff 93       	push	r31
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:183
  if (tx_buffer.head == tx_buffer.tail) {
 442:	80 91 b5 00 	lds	r24, 0x00B5	; 0x8000b5 <__data_end+0x11>
 446:	90 91 b4 00 	lds	r25, 0x00B4	; 0x8000b4 <__data_end+0x10>
 44a:	98 13       	cpse	r25, r24
 44c:	0b c0       	rjmp	.+22     	; 0x464 <__vector_8+0x36>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:188
  // Buffer empty, so disable interrupts
#if defined(UCSR0B)
    cbi(UCSR0B, UDRIE0);
#else
    cbi(UCSRB, UDRIE);
 44e:	55 98       	cbi	0x0a, 5	; 10
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:203
    UDR0 = c;
  #else
    #error UDR not defined
  #endif
  }
}
 450:	ff 91       	pop	r31
 452:	ef 91       	pop	r30
 454:	9f 91       	pop	r25
 456:	8f 91       	pop	r24
 458:	2f 91       	pop	r18
 45a:	0f 90       	pop	r0
 45c:	0f be       	out	0x3f, r0	; 63
 45e:	0f 90       	pop	r0
 460:	1f 90       	pop	r1
 462:	18 95       	reti
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:192
#else
    cbi(UCSRB, UDRIE);
#endif
  } else {
    // There is more data in the output buffer. Send the next byte
    unsigned char c = tx_buffer.buffer[tx_buffer.tail];
 464:	90 e0       	ldi	r25, 0x00	; 0
 466:	fc 01       	movw	r30, r24
 468:	ec 55       	subi	r30, 0x5C	; 92
 46a:	ff 4f       	sbci	r31, 0xFF	; 255
 46c:	20 81       	ld	r18, Z
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:193
    tx_buffer.tail = (tx_buffer.tail + 1) % SERIAL_BUFFER_SIZE;
 46e:	01 96       	adiw	r24, 0x01	; 1
 470:	8f 70       	andi	r24, 0x0F	; 15
 472:	99 27       	eor	r25, r25
 474:	80 93 b5 00 	sts	0x00B5, r24	; 0x8000b5 <__data_end+0x11>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:196

  #if defined(UDR)
    UDR = c;
 478:	2c b9       	out	0x0c, r18	; 12
 47a:	ea cf       	rjmp	.-44     	; 0x450 <__vector_8+0x22>

0000047c <__vector_7>:
__vector_7():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:80
  }
}

#if defined(USART_RX_vect)
  ISR(USART_RX_vect)
  {
 47c:	1f 92       	push	r1
 47e:	0f 92       	push	r0
 480:	0f b6       	in	r0, 0x3f	; 63
 482:	0f 92       	push	r0
 484:	11 24       	eor	r1, r1
 486:	2f 93       	push	r18
 488:	3f 93       	push	r19
 48a:	4f 93       	push	r20
 48c:	5f 93       	push	r21
 48e:	8f 93       	push	r24
 490:	9f 93       	push	r25
 492:	ef 93       	push	r30
 494:	ff 93       	push	r31
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:82
  #if defined(UDR)
    unsigned char c  =  UDR;
 496:	4c b1       	in	r20, 0x0c	; 12
store_char():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:66
  ring_buffer tx_buffer1  =  { { 0 }, 0, 0 };
#endif

inline void store_char(unsigned char c, ring_buffer *buffer)
{
  byte i = (buffer->head + 1) % SERIAL_BUFFER_SIZE;
 498:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <rx_buffer+0x10>
 49c:	90 e0       	ldi	r25, 0x00	; 0
 49e:	9c 01       	movw	r18, r24
 4a0:	2f 5f       	subi	r18, 0xFF	; 255
 4a2:	3f 4f       	sbci	r19, 0xFF	; 255
 4a4:	2f 70       	andi	r18, 0x0F	; 15
 4a6:	33 27       	eor	r19, r19
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:72

  // if we should be storing the received character into the location
  // just before the tail (meaning that the head would advance to the
  // current location of the tail), we're about to overflow the buffer
  // and so we don't write the character or advance the head.
  if (i != buffer->tail) {
 4a8:	50 91 c7 00 	lds	r21, 0x00C7	; 0x8000c7 <rx_buffer+0x11>
 4ac:	52 17       	cp	r21, r18
 4ae:	31 f0       	breq	.+12     	; 0x4bc <__vector_7+0x40>
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:73
    buffer->buffer[buffer->head] = c;
 4b0:	8a 54       	subi	r24, 0x4A	; 74
 4b2:	9f 4f       	sbci	r25, 0xFF	; 255
 4b4:	fc 01       	movw	r30, r24
 4b6:	40 83       	st	Z, r20
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:74
    buffer->head = i;
 4b8:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <rx_buffer+0x10>
__vector_7():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:89
    unsigned char c  =  UDR0;  //  atmega8535
  #else
    #error UDR not defined
  #endif
    store_char(c, &rx_buffer);
  }
 4bc:	ff 91       	pop	r31
 4be:	ef 91       	pop	r30
 4c0:	9f 91       	pop	r25
 4c2:	8f 91       	pop	r24
 4c4:	5f 91       	pop	r21
 4c6:	4f 91       	pop	r20
 4c8:	3f 91       	pop	r19
 4ca:	2f 91       	pop	r18
 4cc:	0f 90       	pop	r0
 4ce:	0f be       	out	0x3f, r0	; 63
 4d0:	0f 90       	pop	r0
 4d2:	1f 90       	pop	r1
 4d4:	18 95       	reti

000004d6 <main>:
main():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
 4d6:	83 e0       	ldi	r24, 0x03	; 3
 4d8:	80 bf       	out	0x30, r24	; 48
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
 4da:	83 bf       	out	0x33, r24	; 51
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
 4dc:	78 94       	sei
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1167

  #ifndef DISABLEMILLIS
    // Enable the overflow interrupt (this is the basic system tic-toc for millis)
    #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
      sbi(TIMSK, TOIE0);
 4de:	89 b7       	in	r24, 0x39	; 57
 4e0:	82 60       	ori	r24, 0x02	; 2
 4e2:	89 bf       	out	0x39, r24	; 57
begin():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:276
#endif
*/
try_again:

  if (use_u2x) {
    *_ucsra = 1 << _u2x;
 4e4:	e0 91 f2 00 	lds	r30, 0x00F2	; 0x8000f2 <Serial+0x14>
 4e8:	f0 91 f3 00 	lds	r31, 0x00F3	; 0x8000f3 <Serial+0x15>
 4ec:	20 91 fc 00 	lds	r18, 0x00FC	; 0x8000fc <Serial+0x1e>
 4f0:	81 e0       	ldi	r24, 0x01	; 1
 4f2:	90 e0       	ldi	r25, 0x00	; 0
 4f4:	ac 01       	movw	r20, r24
 4f6:	02 c0       	rjmp	.+4      	; 0x4fc <main+0x26>
 4f8:	44 0f       	add	r20, r20
 4fa:	55 1f       	adc	r21, r21
 4fc:	2a 95       	dec	r18
 4fe:	e2 f7       	brpl	.-8      	; 0x4f8 <main+0x22>
 500:	40 83       	st	Z, r20
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:290
    use_u2x = false;
    goto try_again;
  }

  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 502:	e0 91 ee 00 	lds	r30, 0x00EE	; 0x8000ee <Serial+0x10>
 506:	f0 91 ef 00 	lds	r31, 0x00EF	; 0x8000ef <Serial+0x11>
 50a:	10 82       	st	Z, r1
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:291
  *_ubrrl = baud_setting;
 50c:	e0 91 f0 00 	lds	r30, 0x00F0	; 0x8000f0 <Serial+0x12>
 510:	f0 91 f1 00 	lds	r31, 0x00F1	; 0x8000f1 <Serial+0x13>
 514:	27 e6       	ldi	r18, 0x67	; 103
 516:	20 83       	st	Z, r18
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:293

  sbi(*_ucsrb, _rxen);
 518:	e0 91 f4 00 	lds	r30, 0x00F4	; 0x8000f4 <Serial+0x16>
 51c:	f0 91 f5 00 	lds	r31, 0x00F5	; 0x8000f5 <Serial+0x17>
 520:	20 81       	ld	r18, Z
 522:	30 91 f8 00 	lds	r19, 0x00F8	; 0x8000f8 <Serial+0x1a>
 526:	ac 01       	movw	r20, r24
 528:	01 c0       	rjmp	.+2      	; 0x52c <main+0x56>
 52a:	44 0f       	add	r20, r20
 52c:	3a 95       	dec	r19
 52e:	ea f7       	brpl	.-6      	; 0x52a <main+0x54>
 530:	24 2b       	or	r18, r20
 532:	20 83       	st	Z, r18
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:294
  sbi(*_ucsrb, _txen);
 534:	e0 91 f4 00 	lds	r30, 0x00F4	; 0x8000f4 <Serial+0x16>
 538:	f0 91 f5 00 	lds	r31, 0x00F5	; 0x8000f5 <Serial+0x17>
 53c:	20 81       	ld	r18, Z
 53e:	30 91 f9 00 	lds	r19, 0x00F9	; 0x8000f9 <Serial+0x1b>
 542:	ac 01       	movw	r20, r24
 544:	01 c0       	rjmp	.+2      	; 0x548 <main+0x72>
 546:	44 0f       	add	r20, r20
 548:	3a 95       	dec	r19
 54a:	ea f7       	brpl	.-6      	; 0x546 <main+0x70>
 54c:	24 2b       	or	r18, r20
 54e:	20 83       	st	Z, r18
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:295
  sbi(*_ucsrb, _rxcie);
 550:	e0 91 f4 00 	lds	r30, 0x00F4	; 0x8000f4 <Serial+0x16>
 554:	f0 91 f5 00 	lds	r31, 0x00F5	; 0x8000f5 <Serial+0x17>
 558:	20 81       	ld	r18, Z
 55a:	30 91 fa 00 	lds	r19, 0x00FA	; 0x8000fa <Serial+0x1c>
 55e:	ac 01       	movw	r20, r24
 560:	01 c0       	rjmp	.+2      	; 0x564 <main+0x8e>
 562:	44 0f       	add	r20, r20
 564:	3a 95       	dec	r19
 566:	ea f7       	brpl	.-6      	; 0x562 <main+0x8c>
 568:	24 2b       	or	r18, r20
 56a:	20 83       	st	Z, r18
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:296
  cbi(*_ucsrb, _udrie);
 56c:	e0 91 f4 00 	lds	r30, 0x00F4	; 0x8000f4 <Serial+0x16>
 570:	f0 91 f5 00 	lds	r31, 0x00F5	; 0x8000f5 <Serial+0x17>
 574:	20 81       	ld	r18, Z
 576:	30 91 fb 00 	lds	r19, 0x00FB	; 0x8000fb <Serial+0x1d>
 57a:	01 c0       	rjmp	.+2      	; 0x57e <main+0xa8>
 57c:	88 0f       	add	r24, r24
 57e:	3a 95       	dec	r19
 580:	ea f7       	brpl	.-6      	; 0x57c <main+0xa6>
 582:	80 95       	com	r24
 584:	82 23       	and	r24, r18
 586:	80 83       	st	Z, r24
setup():
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:12
// #define Kuning A1
// #define Hijau A2

void setup() {
  Serial.begin(9600);
  pinMode (Hitam, OUTPUT);
 588:	89 e0       	ldi	r24, 0x09	; 9
 58a:	81 de       	rcall	.-766    	; 0x28e <pinMode.constprop.8>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:13
  pinMode (Kuning, OUTPUT);
 58c:	8a e0       	ldi	r24, 0x0A	; 10
 58e:	7f de       	rcall	.-770    	; 0x28e <pinMode.constprop.8>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:14
  pinMode (Hijau, OUTPUT);
 590:	8b e0       	ldi	r24, 0x0B	; 11
 592:	7d de       	rcall	.-774    	; 0x28e <pinMode.constprop.8>
loop():
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:53

      // Reset array untuk menerima karakter berikutnya
      memset(data, 0, sizeof(data));
    } else {
      // Selama belum menerima newline, tambahkan karakter ke array
      data[strlen(data)] = receivedChar;
 594:	c8 ec       	ldi	r28, 0xC8	; 200
 596:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:50
        standby ();
      }


      // Reset array untuk menerima karakter berikutnya
      memset(data, 0, sizeof(data));
 598:	1d e0       	ldi	r17, 0x0D	; 13
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:18
  pinMode (Kuning, OUTPUT);
  pinMode (Hijau, OUTPUT);
}

void loop() {
  if (Serial.available() > 0) {
 59a:	8e ed       	ldi	r24, 0xDE	; 222
 59c:	90 e0       	ldi	r25, 0x00	; 0
 59e:	6a de       	rcall	.-812    	; 0x274 <HardwareSerial::available()>
 5a0:	18 16       	cp	r1, r24
 5a2:	19 06       	cpc	r1, r25
 5a4:	d4 f7       	brge	.-12     	; 0x59a <main+0xc4>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:19
    char receivedChar = Serial.read();
 5a6:	8e ed       	ldi	r24, 0xDE	; 222
 5a8:	90 e0       	ldi	r25, 0x00	; 0
 5aa:	3a de       	rcall	.-908    	; 0x220 <HardwareSerial::read()>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:21

    if (receivedChar == '\n') {
 5ac:	8a 30       	cpi	r24, 0x0A	; 10
 5ae:	09 f0       	breq	.+2      	; 0x5b2 <main+0xdc>
 5b0:	47 c0       	rjmp	.+142    	; 0x640 <main+0x16a>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:23
      // Tambahkan null terminator untuk menandai akhir array
      data[13] = '\0';
 5b2:	10 92 d5 00 	sts	0x00D5, r1	; 0x8000d5 <millis_timer_fract>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:27


      // Tampilkan char array yang sudah diisi
      Serial.println(data);
 5b6:	88 ec       	ldi	r24, 0xC8	; 200
 5b8:	90 e0       	ldi	r25, 0x00	; 0
 5ba:	cc de       	rcall	.-616    	; 0x354 <Print::println(char const*) [clone .constprop.3]>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:30

      // Proses ketika kondisi tertentu terpenuhi (contoh: data[0] sampai data[3] adalah "BUKA")
      if (strcmp(data, "IN:GATE:OPEN") == 0) {
 5bc:	60 e7       	ldi	r22, 0x70	; 112
 5be:	70 e0       	ldi	r23, 0x00	; 0
 5c0:	88 ec       	ldi	r24, 0xC8	; 200
 5c2:	90 e0       	ldi	r25, 0x00	; 0
 5c4:	81 d0       	rcall	.+258    	; 0x6c8 <strcmp>
 5c6:	89 2b       	or	r24, r25
 5c8:	71 f4       	brne	.+28     	; 0x5e6 <main+0x110>
atas():
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:70

}

void atas () {

  digitalWrite (Hitam, LOW);
 5ca:	60 e0       	ldi	r22, 0x00	; 0
 5cc:	89 e0       	ldi	r24, 0x09	; 9
 5ce:	7e de       	rcall	.-772    	; 0x2cc <digitalWrite>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:71
  digitalWrite (Kuning, LOW);
 5d0:	60 e0       	ldi	r22, 0x00	; 0
 5d2:	8a e0       	ldi	r24, 0x0A	; 10
 5d4:	7b de       	rcall	.-778    	; 0x2cc <digitalWrite>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:72
  digitalWrite (Hijau, HIGH);                      
 5d6:	61 e0       	ldi	r22, 0x01	; 1
 5d8:	8b e0       	ldi	r24, 0x0B	; 11
 5da:	78 de       	rcall	.-784    	; 0x2cc <digitalWrite>
loop():
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:32
      Serial.println(data);

      // Proses ketika kondisi tertentu terpenuhi (contoh: data[0] sampai data[3] adalah "BUKA")
      if (strcmp(data, "IN:GATE:OPEN") == 0) {
        atas();
        Serial.println("BUKA");
 5dc:	8d e7       	ldi	r24, 0x7D	; 125
 5de:	90 e0       	ldi	r25, 0x00	; 0
 5e0:	b9 de       	rcall	.-654    	; 0x354 <Print::println(char const*) [clone .constprop.3]>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:33
        delay (500);
 5e2:	95 dd       	rcall	.-1238   	; 0x10e <delay.constprop.2>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:34
        standby ();
 5e4:	ae de       	rcall	.-676    	; 0x342 <standby()>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:36
      }
      if (strcmp(data, "IN:GATE:CLOSE") == 0) {
 5e6:	62 e8       	ldi	r22, 0x82	; 130
 5e8:	70 e0       	ldi	r23, 0x00	; 0
 5ea:	88 ec       	ldi	r24, 0xC8	; 200
 5ec:	90 e0       	ldi	r25, 0x00	; 0
 5ee:	6c d0       	rcall	.+216    	; 0x6c8 <strcmp>
 5f0:	89 2b       	or	r24, r25
 5f2:	71 f4       	brne	.+28     	; 0x610 <main+0x13a>
bawah():
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:62
 
}

void bawah () {

  digitalWrite (Hitam, LOW);
 5f4:	60 e0       	ldi	r22, 0x00	; 0
 5f6:	89 e0       	ldi	r24, 0x09	; 9
 5f8:	69 de       	rcall	.-814    	; 0x2cc <digitalWrite>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:63
  digitalWrite (Kuning, HIGH);
 5fa:	61 e0       	ldi	r22, 0x01	; 1
 5fc:	8a e0       	ldi	r24, 0x0A	; 10
 5fe:	66 de       	rcall	.-820    	; 0x2cc <digitalWrite>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:64
  digitalWrite (Hijau, LOW);
 600:	60 e0       	ldi	r22, 0x00	; 0
 602:	8b e0       	ldi	r24, 0x0B	; 11
 604:	63 de       	rcall	.-826    	; 0x2cc <digitalWrite>
loop():
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:38
        delay (500);
        standby ();
      }
      if (strcmp(data, "IN:GATE:CLOSE") == 0) {
        bawah ();
        Serial.println("TUTUP");
 606:	80 e9       	ldi	r24, 0x90	; 144
 608:	90 e0       	ldi	r25, 0x00	; 0
 60a:	a4 de       	rcall	.-696    	; 0x354 <Print::println(char const*) [clone .constprop.3]>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:39
        delay (500);
 60c:	80 dd       	rcall	.-1280   	; 0x10e <delay.constprop.2>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:40
        standby ();
 60e:	99 de       	rcall	.-718    	; 0x342 <standby()>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:42
      }
      if (strcmp(data, "IN:GATE:STOP") == 0) {
 610:	66 e9       	ldi	r22, 0x96	; 150
 612:	70 e0       	ldi	r23, 0x00	; 0
 614:	88 ec       	ldi	r24, 0xC8	; 200
 616:	90 e0       	ldi	r25, 0x00	; 0
 618:	57 d0       	rcall	.+174    	; 0x6c8 <strcmp>
 61a:	89 2b       	or	r24, r25
 61c:	59 f4       	brne	.+22     	; 0x634 <main+0x15e>
stop():
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:80
   
}

void stop () {

  digitalWrite (Hitam, HIGH);
 61e:	61 e0       	ldi	r22, 0x01	; 1
 620:	89 e0       	ldi	r24, 0x09	; 9
 622:	54 de       	rcall	.-856    	; 0x2cc <digitalWrite>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:81
  digitalWrite (Kuning, LOW);
 624:	60 e0       	ldi	r22, 0x00	; 0
 626:	8a e0       	ldi	r24, 0x0A	; 10
 628:	51 de       	rcall	.-862    	; 0x2cc <digitalWrite>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:82
  digitalWrite (Hijau, LOW);
 62a:	60 e0       	ldi	r22, 0x00	; 0
 62c:	8b e0       	ldi	r24, 0x0B	; 11
 62e:	4e de       	rcall	.-868    	; 0x2cc <digitalWrite>
loop():
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:44
        delay (500);
        standby ();
      }
      if (strcmp(data, "IN:GATE:STOP") == 0) {
        stop ();
        delay (500);
 630:	6e dd       	rcall	.-1316   	; 0x10e <delay.constprop.2>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:45
        standby ();
 632:	87 de       	rcall	.-754    	; 0x342 <standby()>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:50
      }


      // Reset array untuk menerima karakter berikutnya
      memset(data, 0, sizeof(data));
 634:	fe 01       	movw	r30, r28
 636:	41 2f       	mov	r20, r17
 638:	11 92       	st	Z+, r1
 63a:	4a 95       	dec	r20
 63c:	e9 f7       	brne	.-6      	; 0x638 <main+0x162>
 63e:	ad cf       	rjmp	.-166    	; 0x59a <main+0xc4>
C:\Users\kedai\Downloads\Gerbang ITERA\Gerbang ITERA\Firmware Gerbang ITERA\FirmwareGate\FirmwareGateV2/FirmwareGateV2.ino:53
    } else {
      // Selama belum menerima newline, tambahkan karakter ke array
      data[strlen(data)] = receivedChar;
 640:	fe 01       	movw	r30, r28
 642:	01 90       	ld	r0, Z+
 644:	00 20       	and	r0, r0
 646:	e9 f7       	brne	.-6      	; 0x642 <main+0x16c>
 648:	31 97       	sbiw	r30, 0x01	; 1
 64a:	80 83       	st	Z, r24
 64c:	a6 cf       	rjmp	.-180    	; 0x59a <main+0xc4>

0000064e <_GLOBAL__sub_I_rx_buffer>:
_ZN5PrintC2Ev():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Print.h:75
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 64e:	ee ed       	ldi	r30, 0xDE	; 222
 650:	f0 e0       	ldi	r31, 0x00	; 0
 652:	13 82       	std	Z+3, r1	; 0x03
 654:	12 82       	std	Z+2, r1	; 0x02
_ZN6StreamC2Ev():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/Stream.h:64
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 656:	88 ee       	ldi	r24, 0xE8	; 232
 658:	93 e0       	ldi	r25, 0x03	; 3
 65a:	a0 e0       	ldi	r26, 0x00	; 0
 65c:	b0 e0       	ldi	r27, 0x00	; 0
 65e:	84 83       	std	Z+4, r24	; 0x04
 660:	95 83       	std	Z+5, r25	; 0x05
 662:	a6 83       	std	Z+6, r26	; 0x06
 664:	b7 83       	std	Z+7, r27	; 0x07
_GLOBAL__sub_I_rx_buffer():
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:232
HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer
#if ( defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H))
  ,volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
  volatile uint8_t *udr,
  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
 666:	84 e6       	ldi	r24, 0x64	; 100
 668:	90 e0       	ldi	r25, 0x00	; 0
 66a:	91 83       	std	Z+1, r25	; 0x01
 66c:	80 83       	st	Z, r24
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:234
{
  _rx_buffer = rx_buffer;
 66e:	86 eb       	ldi	r24, 0xB6	; 182
 670:	90 e0       	ldi	r25, 0x00	; 0
 672:	95 87       	std	Z+13, r25	; 0x0d
 674:	84 87       	std	Z+12, r24	; 0x0c
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:235
  _tx_buffer = tx_buffer;
 676:	84 ea       	ldi	r24, 0xA4	; 164
 678:	90 e0       	ldi	r25, 0x00	; 0
 67a:	97 87       	std	Z+15, r25	; 0x0f
 67c:	86 87       	std	Z+14, r24	; 0x0e
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:236
  _ubrrh = ubrrh;
 67e:	82 e2       	ldi	r24, 0x22	; 34
 680:	90 e0       	ldi	r25, 0x00	; 0
 682:	91 8b       	std	Z+17, r25	; 0x11
 684:	80 8b       	std	Z+16, r24	; 0x10
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:237
  _ubrrl = ubrrl;
 686:	89 e2       	ldi	r24, 0x29	; 41
 688:	90 e0       	ldi	r25, 0x00	; 0
 68a:	93 8b       	std	Z+19, r25	; 0x13
 68c:	82 8b       	std	Z+18, r24	; 0x12
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:238
  _ucsra = ucsra;
 68e:	8b e2       	ldi	r24, 0x2B	; 43
 690:	90 e0       	ldi	r25, 0x00	; 0
 692:	95 8b       	std	Z+21, r25	; 0x15
 694:	84 8b       	std	Z+20, r24	; 0x14
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:239
  _ucsrb = ucsrb;
 696:	8a e2       	ldi	r24, 0x2A	; 42
 698:	90 e0       	ldi	r25, 0x00	; 0
 69a:	97 8b       	std	Z+23, r25	; 0x17
 69c:	86 8b       	std	Z+22, r24	; 0x16
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:240
  _udr = udr;
 69e:	8c e2       	ldi	r24, 0x2C	; 44
 6a0:	90 e0       	ldi	r25, 0x00	; 0
 6a2:	91 8f       	std	Z+25, r25	; 0x19
 6a4:	80 8f       	std	Z+24, r24	; 0x18
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:241
  _rxen = rxen;
 6a6:	84 e0       	ldi	r24, 0x04	; 4
 6a8:	82 8f       	std	Z+26, r24	; 0x1a
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:242
  _txen = txen;
 6aa:	83 e0       	ldi	r24, 0x03	; 3
 6ac:	83 8f       	std	Z+27, r24	; 0x1b
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:243
  _rxcie = rxcie;
 6ae:	87 e0       	ldi	r24, 0x07	; 7
 6b0:	84 8f       	std	Z+28, r24	; 0x1c
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:244
  _udrie = udrie;
 6b2:	85 e0       	ldi	r24, 0x05	; 5
 6b4:	85 8f       	std	Z+29, r24	; 0x1d
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:245
  _u2x = u2x;
 6b6:	81 e0       	ldi	r24, 0x01	; 1
 6b8:	86 8f       	std	Z+30, r24	; 0x1e
C:\Users\kedai\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/HardwareSerial.cpp:396
}

// Preinstantiate Objects //////////////////////////////////////////////////////

#if defined(UBRRH) && defined(UBRRL)
  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UDR, RXEN, TXEN, RXCIE, UDRE, U2X);
 6ba:	08 95       	ret

000006bc <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 6bc:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 6be:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 6c0:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 6c2:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 6c4:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 6c6:	09 94       	ijmp

000006c8 <strcmp>:
strcmp():
 6c8:	fb 01       	movw	r30, r22
 6ca:	dc 01       	movw	r26, r24
 6cc:	8d 91       	ld	r24, X+
 6ce:	01 90       	ld	r0, Z+
 6d0:	80 19       	sub	r24, r0
 6d2:	01 10       	cpse	r0, r1
 6d4:	d9 f3       	breq	.-10     	; 0x6cc <strcmp+0x4>
 6d6:	99 0b       	sbc	r25, r25
 6d8:	08 95       	ret

000006da <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 6da:	f8 94       	cli

000006dc <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 6dc:	ff cf       	rjmp	.-2      	; 0x6dc <__stop_program>
